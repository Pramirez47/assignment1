// Store the base address of the array in X19
ADDI X19, XZR, #8
// Transfer control to procedure, get the base address of the array
LDUR X0, [X19, #0]  // Load the base address of the array into X0
PRNT X0     // Print register

// Place n into a register
ADDI X1, XZR, #16   //n = 8 (this will be used for testing)

BL fill     // Transfer control to 'fill' function
HALT        // End program

// Fill array function
fill: 
    SUBI SP, SP, #8    // Allocate stack space if needed

    // i variable = 0
    ADDI X9, XZR, #0   // Set i to 0 (X9 will be our loop index)

    // // Save n (X1) in X20 because we will modify X1
    // ADDI X20, X1, #0    // X19 = n (saving n in X19 for later use)

    // Start of loop
    forLoop: 
        //make X2 equal to x19
        SUBS X10, X9, X1 // Compare i (X9) with n (X1) by calculating i - n
        B.GE exitLoop    // If i >= n, exit the loop
        
        // Calculate n - i - 1
        SUB X11, X1, X9   // X11 = n - i
        SUBI X11, X11, #1  // X11 = (n - i) - 1

        // Calculate the address for a[i] (a + i * 8)
        LSL X12, X9, #3   // X12 = i * 8 (shift left i by 3)
        ADD X13, X0, X12   // X13 = base address + i * 8 (this is the address of a[i])

        // Store (n - i - 1) into a[i]
        STUR X11, [X13, #0]  // Store X4 (n - i - 1) into a[i]

        // Increment i
        ADDI X9, X9, #1   // i++

        B forLoop         // Jump back to the start of the loop

    // End of loop
    exitLoop:    
    BR LR                // Return from the function
