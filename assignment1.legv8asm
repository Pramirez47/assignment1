// Store the base address of the array in X19
ADDI X19, XZR, #8         // X19 = 8 //address of base array 
LDUR X0, [X19, #0]        // X0 = base address of array (offset is calculated)

// Set values of i, l, and p
ADDI X1, XZR, #3        // i = 7 (starting index)
ADDI X2, XZR, #0          // l = 0 (last index)
ADDI X3, XZR, #4         // p = 10 (partition value)

ADDI X12, XZR, #1         // Load the value 1 into X12
STUR X12, [X0, #0]       // a[0] = 1

ADDI X12, XZR, #3         // Load the value 3 into X12
STUR X12, [X0, #8]       // a[1] = 3

ADDI X12, XZR, #5         // Load the value 5 into X12
STUR X12, [X0, #16]      // a[2] = 5

ADDI X12, XZR, #7         // Load the value 7 into X12
STUR X12, [X0, #24]      // a[3] = 7

ADDI X12, XZR, #9         // Load the value 9 into X12
STUR X12, [X0, #32]      // a[4] = 9

ADDI X12, XZR, #11        // Load the value 11 into X12
STUR X12, [X0, #40]      // a[5] = 11

ADDI X12, XZR, #13        // Load the value 13 into X12
STUR X12, [X0, #48]      // a[6] = 13

ADDI X12, XZR, #15        // Load the value 15 into X12
STUR X12, [X0, #56]      // a[7] = 15


BL next_j
// PRNT X4
HALT                      // End the program

next_j:
    PRNT XZR
    //assume j, f, p are in registers x1, x2, x3
    whileLoop:
        //check if i is less or equal to l (this conditional seems to work)
        SUBS X9, X2, X1   // Compare j (X1) with f (X2)
        B.GE exitLoop      // If f >= j, exit the loop

        // Calculate the address for a[i] (a + i * 8)
        LSL X10, X1, #3    // X10 = i * 8 (shift left i by 3)
        ADD X11, X0, X10   // X11 = base address + i * 8 (this is the address of a[i])
        
        //check if a[j] > p
        LDUR X12, [X11, #0] // Load the value of a[i] into X12
        PRNT X12
        SUBS X13, X12, X3   // Compare a[j] (X12) with p (X3)
        B.LT exitLoop       // If a[j] <= p, exit the loop
    
        // Increment i
        SUBI X1, X1, #1    // i++
        B whileLoop         // Repeat the loop

    exitLoop:
        
        ORR X4, XZR, X1      // Place return value in X4
        PRNT X4
        BR LR               // Return from the function

// Print array function (for testing purposes)
printArray:
    ADDI X9, XZR, #0       // Initialize loop counter (i = 0)
    PRNT X9
    printLoop:
        // Check if i >= n
        SUBS X10, X9, X20       // Compare i with n
        B.GE endPrintLoop      // Exit loop if i >= n

        // Calculate the address of a[i] (a + i * 8)
        LSL X12, X9, #3        // X12 = i * 8
        ADD X13, X0, X12       // X13 = base address + i * 8

        // Load a[i] and print it
        LDUR X11, [X13, #0]    // Load a[i] into X11
        PRNT X11               // Print the value of a[i] (you need a system call for this)

        // Increment i
        ADDI X9, X9, #1        // i++

        B printLoop            // Repeat the loop

    endPrintLoop:
        BR LR                  // Return from function
