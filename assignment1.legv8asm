// Store the base address of the array in X19
ADDI X19, XZR, #8         // Assume array starts at address 8
LDUR X0, [X19, #0]        // Load the base address of the array into X0

// Place n into a register (n = 8 for testing)
ADDI X20, XZR, #8          // n = 8

// Call 'fill' to fill the array
BL fill                   // Transfer control to 'fill' function

// Print the array after 'fill' to check if values are correct
BL printArray              // Call a procedure to print the array

// Set i and j for swapping
ADDI X1, XZR, #3         // i = 2 (3rd element) //2nd element
ADDI X2, XZR, #4         // j = 5 (6th element) //last eleement

// Call 'swap' to swap a[i] and a[j]
BL swap                   // Transfer control to 'swap' function

// Print the array again after swapping
BL printArray              // Call procedure to print the array after swap

HALT                      // End the program

// Fill array function
fill: 
    SUBI SP, SP, #8        // Allocate stack space if needed

    // i variable = 0
    ADDI X9, XZR, #0       // Set i to 0 (X9 will be our loop index)

    // Start of loop
    forLoop: 
        SUBS X10, X9, X20   // Compare i (X9) with n (X1) by calculating i - n
        B.GE exitLoop      // If i >= n, exit the loop

        // Calculate n - i - 1
        SUB X11, X20, X9    // X11 = n - i
        SUBI X11, X11, #1  // X11 = (n - i) - 1

        // Calculate the address for a[i] (a + i * 8)
        LSL X12, X9, #3    // X12 = i * 8 (shift left i by 3)
        ADD X13, X0, X12   // X13 = base address + i * 8 (this is the address of a[i])

        // Store (n - i - 1) into a[i]
        STUR X11, [X13, #0]  // Store X11 (n - i - 1) into a[i]

        // Increment i
        ADDI X9, X9, #1    // i++

        B forLoop          // Jump back to the start of the loop

    // End of loop
    exitLoop:    
    BR LR                  // Return from the function
next_i:
    //assume i, l, p are in registers x1, x2, x3
    whileLoop:
        //check if i is less or equal to l
        SUBS X9, X1, X2   // Compare i (X1) with l (X2)
        B.GT exitLoop      // If i > l, exit the loop

        // Calculate the address for a[i] (a + i * 8)
        LSL X10, X1, #3    // X10 = i * 8 (shift left i by 3)
        ADD X11, X0, X10   // X11 = base address + i * 8 (this is the address of a[i])
        
        //check if a[i] < p
        LDUR X12, [X11, #0] // Load the value of a[i] into X12
        SUBS X13, X12, X3   // Compare a[i] (X14) with p (X3)
        B.GE exitLoop       // If a[i] >= p, exit the loop
    
        // Increment i
        ADDI X1, X1, #1    // i++
        B whileLoop         // Repeat the loop

    exitLoop:
        BR LR               // Return from the function


// Swap function
swap:
    // Calculate the address for a[i] (a + i * 8)
    LSL X10, X1, #3        // X10 = i * 8 (shift left i by 3)
    ADD X11, X0, X10       // X11 = base address + i * 8 (this is the address of a[i])
    LDUR X12, [X11, #0]    // Load a[i] into a register
    ORR X9, XZR, X12       // Store a[i] in X9 (temp)
        
    // Calculate the address for a[j] (a + j * 8)
    LSL X13, X2, #3        // X13 = j * 8 (shift left j by 3)
    ADD X14, X0, X13       // X14 = base address + j * 8 (this is the address of a[j])
    LDUR X15, [X14, #0]    // Load a[j] into a register
    STUR X15, [X11, #0]    // Store a[j] at a[i]
    STUR X9, [X14, #0]     // Store temp (a[i]) at a[j]
    
    BR LR                  // Return from the function

// Print array function (for testing purposes)
printArray:
    ADDI X9, XZR, #0       // Initialize loop counter (i = 0)
    PRNT X9
    printLoop:
        // Check if i >= n
        SUBS X10, X9, X20       // Compare i with n
        B.GE endPrintLoop      // Exit loop if i >= n

        // Calculate the address of a[i] (a + i * 8)
        LSL X12, X9, #3        // X12 = i * 8
        ADD X13, X0, X12       // X13 = base address + i * 8

        // Load a[i] and print it
        LDUR X11, [X13, #0]    // Load a[i] into X11
        PRNT X11               // Print the value of a[i] (you need a system call for this)

        // Increment i
        ADDI X9, X9, #1        // i++

        B printLoop            // Repeat the loop

    endPrintLoop:
        BR LR                  // Return from function
